**Chapter 01 Scala and Data Science**

20世纪下半叶是硅谷的时代。在五十年里，计算机能力从极度缺乏变成了完全的普通。21世纪上半叶是互联网时代。过去20年见证了谷歌、Twitter 和 Facebook 等巨头的崛起，它们永远地改变了我们看待知识的方式。

因特网是个巨大的信息网络。人类的数据中有 90% 是在过去 18 个月产生的。程序员、分析师科学家能利用这些过剩的数据进行深入挖掘，以便商业、政府和慈善机构作出决策。

本书致力介绍一些工具，您需要这些工具来综合大量数据以产生真正的洞察力。

# Data science
数据科学是通过数据挖掘出有用信息的过程。
- 数据科学家必须有骇客技术。数据是通过计算机存储和传输的。计算机、编程语言和库是数据科学家的锤子和凿子；他们必须自信而准确地运用它们，随心所欲地塑造数据。这就是 Scala 的用武之地:它是您的编程工具包中一个强大的工具。
- 数据科学家必须对统计和数值算法有深刻的理解。 优秀的数据科学家将了解机器学习算法的功能以及如何解释结果。 他们不会被误导性的指标，欺骗性的统计数据或误解的因果联系所迷惑。
- 优秀的数据科学家必须对问题领域有深刻的了解。 数据科学过程涉及以科学严谨的方式建立和发现有关问题领域的知识。 因此，数据科学家必须提出正确的问题，了解以前的结果，并了解数据科学工作如何适应更广泛的业务或研究环境。

Drew Conway 用维恩图优雅地总结了这一点，维恩图展示了数据科学与黑客技术、数学和统计知识以及实际专业知识的交叉。

<div align="center">
    <img src="https://raw.githubusercontent.com/keer2345/storehouse/master/2020/0211-01.png">
</div>

当然，很少有人成为上述多个领域中的专家。 数据科学家经常跨职能团队工作，由不同的成员提供不同领域的专业知识。 为了有效运作，团队中的每个成员都必须对这三个领域都具有一般的工作知识。

为了让图像在一个数据科学项目的工作流程的更具体的概述，让我们尝试写一个应用程序，分析公众的感知运动。这就是数据科学管道的样子:
- 获取数据
- 数据摄入
- 浏览数据
- 构建特性
- 模型构建和训练
- 模型推断和预测
- 从模型中提炼智慧和洞察力

# Programming in data science
本书不是讲述数据科学的，而是讲述如何将编程语言 Scala 运用到数据科学之中。那么，如何用编程处理数据呢？

计算机参与了数据科学流程的每一步，但并不定以相同的方式。

假设我们在一家为手机游戏制作的公司中工作，您可以在其中购买游戏中的收益。大多数用户从不购买任何东西，但是一小部分用户可能会花很多钱。我们要建立一个模型，根据大玩家的游戏模式来识别他们。

第一步是浏览数据，找出正确的特征，并构建基于数据的子集。在这个探索阶段，我们有一个明确的目标，但几乎不知道如何实现。我们需要一种轻量级的、灵活的语言和强大的库，以便尽快得到一个工作模型。

一旦有了工作模型，就需要将其部署到游戏平台以分析所有当前用户的使用模式。这有个难题：我们对计划的目标以及如何实现目标有了相对清晰的了解。 我们面临的挑战是如何设计出能够处理所有用户并对未来使用模式的变化保持健壮性的软件。

实际上，我们编写的软件类型通常范围很广，从单个一次性脚本到生产级代码，必须证明它们不会对将来的扩展和负载增加产生影响。 在编写任何代码之前，数据科学家必须了解他们的软件在此频谱上的位置。 我们将其称为永久频谱。

# Why Scala?

有一下几种方式可以证明代码运行前没有 bug ：
- 静态类型检查在编译时以静态类型语言进行，但是也可以在支持类型注释或类型提示的强类型动态语言中使用。 类型检查有助于验证我们是否按预期使用了函数和类。
- 静态分析器和 linter，用于检查未定义的变量或可疑行为（例如，永远无法到达的代码部分）。
- 在编译语言声明不可变的数学或常量。
- 单元测试

运行时的校验有以下方式：
- 静态类型和动态类型语言的动态类型校验。
- 断言

## Static typing and type inference

静态类型面向对象语言通常被批评过于冗长：
```java
Example myInstance = new Example() ;
```
我们重复了两次类的名称 —— 一次是定义编译时的类型，另一次是构建它自身的实例。感觉这样是没有必要的：编译器知道 `myInstance` 的类型是 `Example`（或是 `Example` 的超类）。

Scala 就像大多数的函数式语言，使用类型推断来让编译器推断其类型。在 Scala 中我们可以这样写：
```scala
val myInstance = new Example()
```

## Scala encourages immutability
Scala 鼓励使用不可变的对象。比如：
```scala
val amountSpent = 200
```
默认收集器（collections）也是不可变的：

```scala
val clientIds = List("123", "456")
clientIds(1) = "589"  // Compile-time error
```

## Scala and functional programs
Scala 鼓励函数式编程。许多 Scala 代码都包含使用高阶函数来转换集合。作为程序员，补习遍历集合的细节。让我们写个函数 `occurrencesOf` 来返回列表中某个元素出现的索引：
```scala
def occurrencesOf[A](elem:A, collection:List[A]): List[Int] = {
    for {
        (currentElem, index) <- collection.zipWithIndex
        if (currentElem == elem)
    } yield index
}
```

## Null pointer uncertainty

在 Java 中，使用 `null` 表示缺席的字段。类似的，在 Python 中，使用 `None` 来表示。这是存在风险的，因为我们没有对缺少信息的字段进行编码。

Scala 推荐使用 `Option[T]` 类型来表示可能缺少的属性：
```scala
class User {
  ...
  val email: Option[Email]
  ...
}
```
## Easier parallelism
作为一个例子，有连贯的，限制性的抽象所提供的力量，让我们使用并行集合来解决一个简单的概率问题。我们会计算从 100 次抛硬币中得到至少 60 个人头的概率。我们可以估计这使用蒙特卡罗：我们通过绘制 100 个随机布尔值来模拟 100 次抛硬币值并检查真值的数目是否至少为 60。我们重复一遍直到结果收敛到所需的精度，或者我们厌倦了等待。 
