**2. Getting started with functional programming in Scala**

> nqftjjpp【】sharklasers.com

We'll discuss how to write loops using **_tail recursive function_**, and we'll introduce **_higher-order functions (HOFs)_**. HOFs are functions that take other functions as arguments and may themselves return functions as their output. We’ll also look at some examples of polymorphic HOFs where we use types to guide us toward an implementation.


# 2.1 Introducing Scala the language: an example
```scala
object MyModule {
  def abs(n: Int): Int = {
    if (n < 0) -n
    else n
  }
  
  private def formatAbs(x:Int)={
    val msg = "The absolute value of %d is %d"
    msg.format(x, abs(x))
  }
  
  def main(args:Array[String]):Unit = {
    println(formatAbs(-42))
  }
}
```

# 2.2 Running our program
```
> scalac MyModule.scala
> scala MyModule
The absolute value of -42 is 42.
```

or
```
> scala MyModule.scala
The absolute value of -42 is 42.
```

We can load our source file into the REPL and try things out (your actual console output may differ slightly):
```scala
> scala
Welcome to Scala.
Type in expressions to have them evaluated.
Type :help for more information.

scala> :load MyModule.scala	
Loading MyModule.scala...
defined module MyModule

scala> MyModule.abs(-42)	
res0: Int = 42	
```

It’s also possible to copy and paste individual lines of code into the REPL. It even has a paste mode (accessed with the :paste command) designed to paste code that spans multiple lines. It’s a good idea to get familiar with the REPL and its features because it’s a tool that you’ll use a lot as a Scala programmer.

# 2.3 Modules, objects, and namespaces
```scala
scala> import MyModule.abs
import MyModule.abs

scala> abs(-42)
res0: 42
```
```scala
import MyModule._
```

# 2.4 Higher-order functions: passing functions to functions
## 2.4.1 A short detour: writing loops functionally
```scala
def factorial(n: Int): Int = {
  @annotation.tailrec
  def go(n: Int, acc: Int): Int = {
    if (n <= 0) acc
    else go(n - 1, n * acc)
  }

  go(n, 1)
}
```

## 2.4.2 Writing our first higher-order function
```scala
object MyModule {
  // ...	
  private def formatAbs(x: Int) = {
    val msg = "The absolute value of %d is %d."
    msg.format(x, abs(x))
  }

  private def formatFactorial(n: Int) = {
    val msg = "The factorial of %d is %d."
    msg.format(n, factorial(n))
  }

  def main(args: Array[String]): Unit = {
    println(formatAbs(-42))
    println(formatFactorial(7))
  }
}
```

```scala
def formatResult(name: String, n: Int, f: Int => Int) = {	
  val msg = "The %s of %d is %d."
  msg.format(name, n, f(n))
}
```



```scala
scala> formatResult("absolute value", -42, abs)
res0: String = "The absolute value of -42 is 42."

scala> formatResult("factorial", 7, factorial)
res1: String = "The factorial of 7 is 5040."
```

# 2.5 Polymorphic functions: abstracting over types
